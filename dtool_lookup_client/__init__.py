"""dtool_lookup_client package."""

from datetime import date, datetime

import click
import json
import logging

import pygments
import pygments.lexers
import pygments.formatters

import dtoolcore
import dtoolcore.utils
import dtool_config.cli
import dtool_lookup_api


logger = logging.getLogger(__name__)


# workaround for diverging python versions:
try:
    from importlib.metadata import version, PackageNotFoundError
    logger.debug("imported version, PackageNotFoundError from importlib.metadata")
except ModuleNotFoundError:
    from importlib_metadata import version, PackageNotFoundError
    logger.debug("imported version, PackageNotFoundError from importlib_metadata")

# first, try to determine dynamic version at runtime
try:
    __version__ = version(__name__)
    logger.debug("Determined version %s via importlib_metadata.version", __version__)
except PackageNotFoundError:
    # if that fails, check for static version file written by setuptools_scm
    try:
        from .version import version as __version__
        logger.debug("Determined version %s from autogenerated dtool_lookup_client/version.py", __version__)
    except:
        logger.debug("All efforts to determine version failed.")
        __version__ = None


DSERVER_URL_KEY = "DSERVER_URL"
DSERVER_TOKEN_KEY = "DSERVER_TOKEN"


def json_serial(obj):
    if isinstance(obj, (datetime, date)):
        return obj.isoformat()
    raise TypeError("Type {} not serializable".format(type(obj)))


def uris_from_lookup_response(response):
    """Return list of URIs from  response from /lookup_datasets/<uuid>."""
    return [item["uri"] for item in response]


def urljoin(*args):
    parts = []
    for p in args:
        if p.endswith("/"):
            p = p[:-1]
        parts.append(p)
    return "/".join(parts)


@click.command()
@click.argument("uuid")
def lookup(uuid):
    """Print the URIs associated with a UUID in the lookup server."""
    r = dtool_lookup_api.get_datasets_by_uuid(uuid)
    for uri in uris_from_lookup_response(r):
        click.secho(uri)


@click.command()
@click.argument("free-text", default="")
@click.option("--creator-username", multiple=True,
              help=("Filter results to only return datasets created by this user."
                    "Provide multiple times to filter by multiple users (logical OR)."))
@click.option("--base-uri", multiple=True,
              help=("Filter results to only return datasets at specified base URI."
                    "Provide multiple times to filter by multiple base URIs (logical OR)."))
@click.option("--uuid", multiple=True,
              help=("Filter results to only return datasets of specified UUID."
                    "Provide multiple times to filter by multiple UUIDs (logical OR."))
@click.option("--tag", multiple=True,
              help=("Filter results to only return datasets matching this tag."
                    "Provide multiple times match all tags (logical AND.)"))
@click.option("--page-size", "-n", default=10,
              help="Retrieve that many datasets per page.")
@click.option("--page", "-p", default=1,
              help="Show this page.")
@click.option("--pagination-info", is_flag=True,
              help="Print pagination information to stderr.")
def search(free_text, creator_username, base_uri, uuid, tag, page_size, page,
           pagination_info):
    """Free-text search for datasets registered on dserver."""
    # click passes empty tuples if no value specified
    if len(creator_username) == 0:
        creator_username = None
    if len(base_uri) == 0:
        base_uri = None
    if len(uuid) == 0:
        uuid = None
    if len(tag) == 0:
        tag = None

    pagination = {}
    r = dtool_lookup_api.get_datasets(
        free_text=free_text,
        creator_usernames=creator_username,
        base_uris=base_uri,
        uuids=uuid,
        tags=tag,
        page_size=page_size,
        page_number=page,
        pagination=pagination
    )
    formatted_json = json.dumps(r, indent=2)
    colorful_json = pygments.highlight(
        formatted_json,
        pygments.lexers.JsonLexer(),
        pygments.formatters.TerminalFormatter())

    if pagination_info:
        formatted_pagination_json = json.dumps({"pagination": pagination}, indent=2)
        colorful_pagination_json = pygments.highlight(
            formatted_pagination_json,
            pygments.lexers.JsonLexer(),
            pygments.formatters.TerminalFormatter())
        click.secho(colorful_pagination_json, nl=False, err=True)

    click.secho(colorful_json, nl=False)


@click.command()
@click.argument("query", default="")
@click.option("--creator-username", multiple=True,
              help=("Filter results to only return datasets created by this user."
                    "Provide multiple times to filter by multiple users (logical OR)."))
@click.option("--base-uri", multiple=True,
              help=("Filter results to only return datasets at specified base URI."
                    "Provide multiple times to filter by multiple base URIs (logical OR)."))
@click.option("--uuid", multiple=True,
              help=("Filter results to only return datasets of specified UUID."
                    "Provide multiple times to filter by multiple UUIDs (logical OR."))
@click.option("--tag", multiple=True,
              help=("Filter results to only return datasets matching this tag."
                    "Provide multiple times match all tags (logical AND.)"))
@click.option("--page-size", "-n", default=10,
              help="Retrieve that many datasets per page.")
@click.option("--page", "-p", default=1,
              help="Show this page.")
@click.option("--pagination-info", is_flag=True,
              help="Print pagination information to stderr.")
def query(query, creator_username, base_uri, uuid, tag, page_size, page,
           pagination_info):
    """MongoDB No-SQL language query for datasets registered on dserver."""
    if len(creator_username) == 0:
        creator_username = None
    if len(base_uri) == 0:
        base_uri = None
    if len(uuid) == 0:
        uuid = None
    if len(tag) == 0:
        tag = None

    pagination = {}
    r = dtool_lookup_api.query(
        query=query,
        creator_usernames=creator_username,
        base_uris=base_uri,
        uuids=uuid,
        tags=tag,
        page_size=page_size,
        page_number=page,
        pagination=pagination
    )

    formatted_json = json.dumps(r, indent=2)
    colorful_json = pygments.highlight(
        formatted_json,
        pygments.lexers.JsonLexer(),
        pygments.formatters.TerminalFormatter())

    if pagination_info:
        formatted_pagination_json = json.dumps({"pagination": pagination}, indent=2)
        colorful_pagination_json = pygments.highlight(
            formatted_pagination_json,
            pygments.lexers.JsonLexer(),
            pygments.formatters.TerminalFormatter())
        click.secho(colorful_pagination_json, nl=False, err=True)

    click.secho(colorful_json, nl=False)


#############################################################################
# Add click group to 'dtool config' with options for configuring connection
# to dserver.
#############################################################################

@dtool_config.cli.config.group()
def lookup_server():
    """Configure dserver connection."""


@lookup_server.command()
@click.argument("dserver_url", required=False)
def url(dserver_url):
    """Display / set / update URL for dserver."""
    if dserver_url is None:
        click.secho(dtoolcore.utils.get_config_value_from_file(
            DSERVER_URL_KEY, default=""
        ))
    else:
        click.secho(dtoolcore.utils.write_config_value_to_file(
            DSERVER_URL_KEY,
            dserver_url
        ))


@lookup_server.command()
@click.argument("dserver_token", required=False)
def token(dserver_token):
    """Display / set / update token for dserver."""
    if dserver_token is None:
        click.secho(dtoolcore.utils.get_config_value_from_file(
            DSERVER_TOKEN_KEY, default=""
        ))
    else:
        click.secho(dtoolcore.utils.write_config_value_to_file(
            DSERVER_TOKEN_KEY,
            dserver_token
        ))
